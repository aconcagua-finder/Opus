generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String     @id @default(uuid())
  email                     String     @unique
  passwordHash              String?    @map("password_hash")
  emailVerified             DateTime?  @map("email_verified")
  emailVerificationToken    String?    @map("email_verification_token")
  emailVerificationExpiresAt DateTime? @map("email_verification_expires_at")
  
  // Profile
  username                  String?    @unique
  displayName               String?    @map("display_name")
  avatarUrl                 String?    @map("avatar_url")
  
  // Status
  isActive                  Boolean    @default(true) @map("is_active")
  isBanned                  Boolean    @default(false) @map("is_banned")
  banReason                 String?    @map("ban_reason")
  bannedUntil               DateTime?  @map("banned_until")
  
  // Metadata
  metadata                  Json       @default("{}")
  
  // Timestamps
  createdAt                 DateTime   @default(now()) @map("created_at")
  updatedAt                 DateTime   @updatedAt @map("updated_at")
  deletedAt                 DateTime?  @map("deleted_at")
  lastLoginAt               DateTime?  @map("last_login_at")
  
  // Relations
  sessions                  Session[]
  passwordResetTokens       PasswordResetToken[]
  authAttempts              AuthAttempt[]
  accounts                  Account[]
  dictionaryEntries         DictionaryEntry[]
  wordLists                 WordList[]

  @@map("users")
  @@index([email])
  @@index([username])
  @@index([deletedAt])
}

model Session {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  refreshToken    String    @unique @map("refresh_token")
  
  // Session info
  ipAddress       String?   @map("ip_address")
  userAgent       String?   @map("user_agent")
  deviceInfo      Json      @default("{}") @map("device_info")
  
  // Expiration
  expiresAt       DateTime  @map("expires_at")
  lastActivityAt  DateTime  @default(now()) @map("last_activity_at")
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  revokedAt       DateTime? @map("revoked_at")
  revokedReason   String?   @map("revoked_reason")
  
  // Relations
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("sessions")
  @@index([userId])
  @@index([refreshToken])
  @@index([expiresAt])
}

model PasswordResetToken {
  id         String    @id @default(uuid())
  userId     String    @map("user_id")
  token      String    @unique
  expiresAt  DateTime  @map("expires_at")
  usedAt     DateTime? @map("used_at")
  createdAt  DateTime  @default(now()) @map("created_at")
  
  // Relations
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("password_reset_tokens")
  @@index([token])
  @@index([userId])
}

model AuthAttempt {
  id            String    @id @default(uuid())
  email         String
  userId        String?   @map("user_id")
  ipAddress     String?   @map("ip_address")
  userAgent     String?   @map("user_agent")
  success       Boolean
  failureReason String?   @map("failure_reason")
  createdAt     DateTime  @default(now()) @map("created_at")
  
  // Relations
  user          User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@map("auth_attempts")
  @@index([email])
  @@index([ipAddress])
  @@index([createdAt])
}

// NextAuth.js Models
model Account {
  id                String  @id @default(uuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Dictionary Models
model DictionaryEntry {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  
  // Основное слово
  word         String
  sourceLanguage Language @map("source_language")
  
  // Перевод
  translation  String
  targetLanguage Language @map("target_language")
  
  // Дополнительные поля
  notes        String?  // Заметки пользователя
  difficulty   Int?     @default(0) // Уровень сложности (0-5)
  
  // Статистика изучения
  timesViewed  Int      @default(0) @map("times_viewed")
  timesCorrect Int      @default(0) @map("times_correct")
  lastReviewed DateTime? @map("last_reviewed")
  
  // Временные метки
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")
  
  // Связи
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  wordListItems WordListItem[]

  @@map("dictionary_entries")
  @@index([userId])
  @@index([sourceLanguage])
  @@index([targetLanguage])
  @@index([createdAt])
  @@index([userId, sourceLanguage])
  @@index([userId, word])
}

// Word Lists Models
model WordList {
  id          String       @id @default(uuid())
  userId      String       @map("user_id")
  name        String
  type        WordListType @default(CUSTOM)
  description String?
  color       String?
  isArchived  Boolean      @default(false) @map("is_archived")

  // Timestamps
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @updatedAt @map("updated_at")

  // Relations
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  wordListItems WordListItem[]

  @@map("word_lists")
  @@index([userId])
  @@index([userId, type])
  @@index([userId, isArchived])
}

model WordListItem {
  id      String   @id @default(uuid())
  listId  String   @map("list_id")
  entryId String   @map("entry_id")

  // Timestamp
  addedAt DateTime @default(now()) @map("added_at")

  // Relations
  list  WordList        @relation(fields: [listId], references: [id], onDelete: Cascade)
  entry DictionaryEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)

  @@unique([listId, entryId])
  @@map("word_list_items")
  @@index([listId])
  @@index([entryId])
}

enum Language {
  SPANISH
  ENGLISH
  RUSSIAN
}

enum WordListType {
  CUSTOM
  AUTO_7_DAYS
  AUTO_14_DAYS
  AUTO_28_DAYS
}